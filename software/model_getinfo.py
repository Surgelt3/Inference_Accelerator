"""Script generated by chatgpt"""


import onnx
from onnx import shape_inference, numpy_helper

model = onnx.load("mobilenet_v2.onnx")
model = shape_inference.infer_shapes(model)

g = model.graph

# 1) value_info map (shapes of graph inputs/intermediates/outputs)
vi_map = {}
for v in list(g.input) + list(g.value_info) + list(g.output):
    tt = v.type.tensor_type
    if tt.HasField("shape"):
        dims = [d.dim_value for d in tt.shape.dim]
        vi_map[v.name] = dims

# 2) initializer map (weights/bias tensors live here)
init_map = { init.name: init for init in g.initializer }

def get_shape(name):
    """Return list of dims for a tensor name, from value_info or initializers.
       Returns None if unknown."""
    if name in vi_map:
        return vi_map[name]
    if name in init_map:
        return list(init_map[name].dims)
    return None

def conv_inputs(node):
    """Return (X_name, W_name, B_name_or_None) for a Conv node, robustly."""
    X_name = None
    W_name = None
    B_name = None
    for inp in node.input:
        if inp in init_map:
            # weight or bias (check dims to tell)
            dims = list(init_map[inp].dims)
            if len(dims) >= 2 and (W_name is None):  # prefer first big tensor as weights
                W_name = inp
            else:
                B_name = inp
        else:
            # likely activation tensor
            if X_name is None:
                X_name = inp
    return X_name, W_name, B_name

def gemm_inputs(node):
    """Return (A_name, B_name, C_name_or_None) for Gemm/MatMul, detecting initializers."""
    A_name = None
    B_name = None
    C_name = None
    # Prefer initializers as weights/bias
    for inp in node.input:
        if inp in init_map:
            if B_name is None:
                B_name = inp
            else:
                C_name = inp
        else:
            if A_name is None:
                A_name = inp
    # Fallback if not found
    if A_name is None and len(node.input) > 0:
        A_name = node.input[0]
    if B_name is None and len(node.input) > 1:
        B_name = node.input[1]
    if C_name is None and len(node.input) > 2:
        C_name = node.input[2]
    return A_name, B_name, C_name

# Example usage in your loop
from onnx import helper

def get_attr(node, key, default):
    for a in node.attribute:
        if a.name == key:
            return helper.get_attribute_value(a)
    return default

rows = [["layer","type","M","K","N","Hout","Wout","Kh","Kw","Sh","Sw","Ph","Pw","groups"]]

for i, node in enumerate(g.node):
    if node.op_type == "Conv":
        X_name, W_name, B_name = conv_inputs(node)
        X_shape = get_shape(X_name)   # e.g., [B,Cin,Hin,Win] (NCHW)
        W_shape = get_shape(W_name)   # e.g., [Cout,Cin/group,Kh,Kw] from initializer

        if X_shape is None or W_shape is None:
            # Skip or warn gracefully instead of crashing
            print(f"[warn] missing shape for Conv inputs at node {i}: {X_name}, {W_name}")
            continue

        B, Cin, Hin, Win = X_shape
        Cout, Cin_g, Kh, Kw = W_shape

        strides = get_attr(node, "strides", [1,1])
        pads    = get_attr(node, "pads", [0,0,0,0])
        dil     = get_attr(node, "dilations", [1,1])
        groups  = get_attr(node, "group", 1)

        Sh, Sw = strides
        Ph, Pw = pads[0], pads[1]
        Dh, Dw = dil

        Hout = (Hin + 2*Ph - Dh*(Kh-1) - 1)//Sh + 1
        Wout = (Win + 2*Pw - Dw*(Kw-1) - 1)//Sw + 1

        M = B * Hout * Wout
        K = (Cin // groups) * Kh * Kw
        N = Cout

        rows.append([f"conv_{i}","gemm",M,K,N,Hout,Wout,Kh,Kw,Sh,Sw,Ph,Pw,groups])

    elif node.op_type in ("Gemm","MatMul"):
        A_name, B_name, C_name = gemm_inputs(node)
        A_shape = get_shape(A_name)
        B_shape = get_shape(B_name)
        if A_shape is None or B_shape is None:
            print(f"[warn] missing shape for {node.op_type} inputs at node {i}: {A_name}, {B_name}")
            continue
        M, K = A_shape[-2], A_shape[-1]
        N    = B_shape[-1]
        rows.append([f"{node.op_type.lower()}_{i}","gemm",M,K,N,"","","","","","","","",""])

# write CSV
import csv
with open("mobilenet_layers.csv","w",newline="") as f:
    csv.writer(f).writerows(rows)
